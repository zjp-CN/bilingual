---
source: tests/pulldown_cmark.rs
expression: "Parser::new(&md).collect::<Vec<_>>()"

---
- Start:
    Heading: H1
- Text: I/O event queue
- End:
    Heading: H1
- Start: Paragraph
- Text: "The I/O event queue is what handles most of our I/O tasks. Now we'll go through"
- SoftBreak
- Text: "how we register events to that queue later on, but once an event is ready we"
- SoftBreak
- Text: "it sends the "
- Code: event_id
- Text: " through our channel."
- End: Paragraph
- Start:
    CodeBlock:
      Fenced: "rust, ignored"
- Text: "fn process_epoll_events(&mut self, event_id: usize) {\n    self.callbacks_to_run.push((event_id, Js::Undefined));\n    self.epoll_pending_events -= 1;\n}\n"
- End:
    CodeBlock:
      Fenced: "rust, ignored"
- Start: Paragraph
- Text: "As we'll see later on, the way we designed this, we actually made our "
- Code: event_id
- SoftBreak
- Text: "and "
- Code: callback_id
- Text: " the same value since both represents an unique value for this"
- SoftBreak
- Text: event. It simplifies things slightly for us.
- End: Paragraph
- Start: Paragraph
- Text: "We add the "
- Code: callback_id
- Text: " to the collection of callbacks to run. We pass"
- SoftBreak
- Text: "in "
- Code: "Js::Undefined"
- Text: " since we'll not actually pass any data along here. You'll see"
- SoftBreak
- Text: "why when we reach the "
- Start:
    Link:
      - Inline
      - "./8_3_http_module.md"
      - ""
- Text: Http module
- End:
    Link:
      - Inline
      - "./8_3_http_module.md"
      - ""
- Text: " chapter, but the main"
- SoftBreak
- Text: "point is that the I/O queue doesn't return any data itself, it just tells us that"
- SoftBreak
- Text: data is ready to be read.
- End: Paragraph
- Start: Paragraph
- Text: "Lastly it's only for our own bookkeeping we decrement the count of outstanding"
- SoftBreak
- Code: epoll_pending_events
- Text: " so we keep track of how many events we have pending."
- End: Paragraph
- Start: BlockQuote
- Start: Paragraph
- Start: Strong
- Text: "Why even keep track of how many "
- Code: epoll_events
- Text: " are pending?"
- End: Strong
- SoftBreak
- Text: "We don't use this value here, but I added it to make it easier to create"
- SoftBreak
- Text: "some "
- Code: print
- Text: " statements showing the status of our runtime at different points."
- SoftBreak
- Text: "However, there are good reasons to keep track of these events even if we don't use them."
- End: Paragraph
- Start: Paragraph
- Text: "One area we're taking shortcuts on all the way here is security. If someone were"
- SoftBreak
- Text: "to build a public facing server out of this, we need to account for slow networks"
- SoftBreak
- Text: and malicious users.
- End: Paragraph
- Start: Paragraph
- Text: "Since we use "
- Code: IOCP
- Text: ", which is a completion based model, we allocate memory for"
- SoftBreak
- Text: "a buffer for each "
- Code: Read
- Text: " or "
- Code: Write
- Text: " event. When we lend this memory to the OS,"
- SoftBreak
- Text: "we're in a weird situation. We own it, but we can't touch it. There are several"
- SoftBreak
- Text: "ways in which we could register interest in more events than occur, and thereby"
- SoftBreak
- Text: allocating memory that is just held in the buffers. Now if someone wanted to crash
- SoftBreak
- Text: "our server, they could cause this intentionally."
- End: Paragraph
- Start: Paragraph
- Text: "A good practice is therefore to create a \"high watermark\" by keeping track of"
- SoftBreak
- Text: "the number of pending events, and when we reach that watermark, we queue events"
- SoftBreak
- Text: instead of registering them with the OS.
- End: Paragraph
- Start: Paragraph
- Text: "By extension, this is also why you should "
- Start: Strong
- Text: always
- End: Strong
- Text: " have a timeout on these events"
- SoftBreak
- Text: so that you at some point can reclaim the memory and return an timeout error if
- SoftBreak
- Text: necessary.
- End: Paragraph
- End: BlockQuote

